% Copyright 2022 Florian Pesth
%
% This file is part of cppnuweb.
%
% cppnuweb is free software: you can redistribute it and/or modify
% it under the terms of the GNU Affero General Public License as
% published by the Free Software Foundation version 3 of the
% License.
%
% cppnuweb is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU Affero General Public License for more details.
%
% You should have received a copy of the GNU Affero General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

\chapter{Nuweb Parser}

We try to use the Flex and Bison programs to create our parser.

\section{Lexical analysis}
\codebisonflex
@O ../src/nuweb.l
@{
%{
#include <iostream>
#include "../../src/helplexer.h"
#include "parser.hpp"

#define DEBUG_LEXER(X) std::cout << X << " "; std::cout.flush();
#define TOKEN(X) DEBUG_LEXER(#X) return yy::parser::token::yytokentype::X;
%}

%option c++
%option noyywrap
%option yylineno

%x f


%%
 /* rules */
[^@@]+ { TOKEN(TEX_WITHOUT_AT) }
<INITIAL>"@@{" { BEGIN(f); TOKEN(AT_CURLY_BRACKET_OPEN) }
<f>"@@}" { BEGIN(INITIAL); TOKEN(AT_CURLY_BRACKET_CLOSE) }
<INITIAL>"@@[" { BEGIN(f); TOKEN(AT_SQUARE_BRACKET_OPEN) }
<f>"@@]" { BEGIN(INITIAL); TOKEN(AT_SQUARE_BRACKET_CLOSE) }
<INITIAL,f>"@@(" { BEGIN(f); TOKEN(AT_ROUND_BRACKET_OPEN) }
<f>"@@)"         { BEGIN(INITIAL); TOKEN(AT_ROUND_BRACKET_CLOSE) }
<f>"@@<"         { BEGIN(f); TOKEN(AT_ANGLE_BRACKET_OPEN) }
<f>"@@<+"        { BEGIN(f); TOKEN(AT_ANGLE_BRACKET_OPEN_PLUS) }
<f>"@@>"         { BEGIN(INITIAL); TOKEN(AT_ANGLE_BRACKET_CLOSE) }
<*>"@@@@"               { TOKEN(AT_AT) }
<*>"@@_" { TOKEN(AT_UNDERLINE) }
<*>"@@i" { TOKEN(AT_I) }
<*>"@@v" { TOKEN(AT_V) }
<*>"@@o" { TOKEN(AT_SMALL_O) }
<*>"@@O" { TOKEN(AT_LARGE_O) }
<*>"@@d" { TOKEN(AT_SMALL_D) }
<*>"@@d+" { TOKEN(AT_SMALL_D_PLUS) }
<*>"@@D" { TOKEN(AT_LARGE_D) }
<*>"@@D+" { TOKEN(AT_LARGE_D_PLUS) }
<*>"@@q" { TOKEN(AT_SMALL_Q) }
<*>"@@q+" { TOKEN(AT_SMALL_Q_PLUS) }
<*>"@@Q" { TOKEN(AT_LARGE_Q) }
<*>"@@Q+" { TOKEN(AT_LARGE_Q_PLUS) }
<*>"@@f" { TOKEN(AT_SMALL_F) }
<*>"@@F" { TOKEN(AT_LARGE_F) }
<*>"@@'" { TOKEN(AT_TICK) }
<*>"@@x" { TOKEN(AT_X) }
<*>"@@t" { TOKEN(AT_T) }
<*>"@@#" { TOKEN(AT_HASH) }
<*>"@@s" { TOKEN(AT_SMALL_S) }
<*>"@@S" { TOKEN(AT_LARGE_S) }
<*>"@@m" { TOKEN(AT_M) }
<*>"@@m+" { TOKEN(AT_M_PLUS) }
<*>"@@u" { TOKEN(AT_U) }
<*>"@@u+" { TOKEN(AT_U_PLUS) }
<*>"@@%" { TOKEN(AT_PERCENT) }
<*>"@@|" { TOKEN(AT_PIPE) }
<*>"@@+" { TOKEN(AT_PLUS) }
<*>"@@+" { TOKEN(AT_MINUS) }
<*>[@@][1-9] { TOKEN(AT_NUMBER) } 
<*>"-d" { TOKEN(FLAG_D) }
<*>"-i" { TOKEN(FLAG_I) }
<*>"-t" { TOKEN(FLAG_T) }
<*>"-cc" { TOKEN(FLAG_C_C) }
<*>"-c+" { TOKEN(FLAG_C_PLUS) }
<*>"-cp" { TOKEN(FLAG_C_P) }
<<EOF>> { TOKEN(YYEOF) }
%%

 /* code */
@}

\section{Context free grammar}

The context free grammar is defined by a Bison file. We use the C++ code generator of Bison as well as the C++ code generator for Flex which leads to some extra work.

@O ../src/nuweb.y
@{

%require "3.2"
%language "c++"

@<Parse parameters@>
@<Flex parameters@>
@}

\subsection{Glue code between Bison and Flex}
\codecpp
Apparently there is some glue code needed so that Bison and Flex can talk to each other when using C++ for both. It seems it is easier if at least Flex is C, but I want to have only C++ code here. The code between \%\{ and \%\} is included at the beginning of the generated file. \lstinline{"parser.hpp"} is a header generated by Bison via the cmake rules and will contain the token definitions for example which are generated by the \verb|%token| commands following in the bison file below.

\codebisonflex
@O ../src/nuweb.y
@{
%code requires {
    #include <iostream>
    #include "parser.hpp"
    #include "../../src/ast.h"
    class helpLexer;
}
@}

\codecpp
Here we need to fix a problem. Bison wants to call a function of type ``\lstinline{int yylex(yy::parser::semantic_type* yylvalue);}'' while Flex provides a method of type ``\lstinline{int yyFlexLexer::yylex(void);}''. We create a new ``\lstinline{class helpLexer : public yyFlexLexer}'' and store the value in this class. We provide a wrapper function here for Bison which has an additional argument ``\lstinline{helpLexer* lexer}'' to pass a pointer to our class object.

@O ../src/nuweb.y
@{
%code {
    #include "../../src/helplexer.h"
    int yylex(yy::parser::semantic_type* yylvalue, helpLexer* lexer){
        return lexer->yylex(yylvalue);
    };
    void yy::parser::error(const std::string& s){
        /* TODO Throw error here */
        std::cout << s;
    };
}
@}

We need to tell Bison about this new argument of course:

\codebisonflex
@d Flex parameters
@{
%lex-param { helpLexer* lexer }
@}

\codecpp
We also need to pass a pointer to this \lstinline{helpLexer} object in the constructor of the ``\lstinline{class yy::parser}'' which is generated for us by Bison.

\codebisonflex
@d Parse parameters
@{
%parse-param { helpLexer* lexer }
%parse-param { statement** l_statement }
@}

So let's go ahead and write this helper class.

\codecpp
@O ../src/helplexer.h -d
@{
@<Start of @'HELPLEXER@' header@>

#if !defined(yyFlexLexerOnce)
#include <FlexLexer.h>
#endif

#include "parser.hpp"

@<Start of class @'helpLexer@' base @'yyFlexLexer@'@>
private:
    yy::parser::semantic_type* yylvalue;
    int yylex(void);
public:
    helpLexer(std::istream& inputStream, std::ostream& outputStream);
    int yylex(yy::parser::semantic_type* yylvalue);
@<End of class and header@>
@}

We need to still define the constructor ``\lstinline{helpLexer::helpLexer(std::istream&, std::ostream&);}'' and ``\lstinline{int helpLexer::yylex(yy::parser::semantic_type* yylvalue);}'' but let's not use a seperate file for this but put it at the end of the Bison file later:

@d Function definition for int yylex(yy::parser::semantic_type* yylvalue);
@{
int helpLexer::yylex(void){
    /* Should never be called */
    return 0;
}

helpLexer::helpLexer(std::istream& inputStream, std::ostream& outputStream) : yyFlexLexer(inputStream, outputStream) {
}

int helpLexer::yylex(yy::parser::semantic_type* yylvalue){
    this->yylvalue = yylvalue;
    return yyFlexLexer::yylex();
}
@}

\subsection{Tokens}

\codebisonflex
@O ../src/nuweb.y
@{

%token TEX_WITHOUT_AT
%token FILENAME
%token AT_CURLY_BRACKET_OPEN AT_CURLY_BRACKET_CLOSE AT_SQUARE_BRACKET_OPEN AT_SQUARE_BRACKET_CLOSE AT_ROUND_BRACKET_OPEN AT_ROUND_BRACKET_CLOSE AT_ANGLE_BRACKET_OPEN AT_ANGLE_BRACKET_CLOSE AT_ANGLE_BRACKET_OPEN_PLUS 
%token AT_I AT_AT AT_UNDERLINE AT_TICK AT_NUMBER AT_X AT_T AT_HASH AT_S AT_PERCENT AT_V AT_M AT_M_PLUS AT_U
%token AT_PIPE AT_MINUS AT_PLUS AT_U_PLUS
%token FLAG_D FLAG_I FLAG_T FLAG_C_C FLAG_C_PLUS FLAG_C_P
%token AT_SMALL_O AT_LARGE_O AT_SMALL_D AT_LARGE_D AT_SMALL_Q AT_LARGE_Q AT_SMALL_F AT_LARGE_F AT_LARGE_D_PLUS AT_SMALL_D_PLUS AT_LARGE_Q_PLUS AT_SMALL_S AT_SMALL_Q_PLUS AT_LARGE_S

%union
{
    int m_int;
}

%%
 /* rules */
nuwebfile
    : statements YYEOF
;

statements
    : %empty
    | statements statement
;

statement
    : TEX_WITHOUT_AT
    | fragment
    | include
    | escapedchar
;
@}

\subsection{Fragment}
@O ../src/nuweb.y
@{
fragment
    : fragmentHeader scrap
;
@}

\subsubsection{Header}
@O ../src/nuweb.y
@{
fragmentHeader
    : AT_SMALL_D fragmentName
;

fragmentName
    : %empty
    | fragmentName fragmentNamePart
;

fragmentNamePart
    : TEX_WITHOUT_AT
    | fragmentNameArgument
;

fragmentNameArgument
    : AT_TICK TEX_WITHOUT_AT AT_TICK
;
@}

\subsection{Scrap}
A scrap can be typeset in three ways, as verbatim, as paragraph or as math:

\begin{figure}[h]
\begin{grammar}
<scrap> ::= '@@\{' <scrapElements> '@@\}'; verbatim
\alt '@@[' <scrapElements> '@@]'; paragraph
\alt '@@(' <scrapElements> '@@)'; math
\end{grammar}
\caption{BNF for scrap}
\end{figure}

@O ../src/nuweb.y
@{
scrap
    : AT_CURLY_BRACKET_OPEN scrapElements AT_CURLY_BRACKET_CLOSE
    | AT_SQUARE_BRACKET_OPEN scrapElements AT_SQUARE_BRACKET_CLOSE
    | AT_ROUND_BRACKET_OPEN scrapElements AT_ROUND_BRACKET_CLOSE
;

scrapElements
    : %empty
    | scrapElements scrapElement
;

scrapElement
    : TEX_WITHOUT_AT
    | AT_AT
;

include
    : AT_I includefilename
;

includefilename
    : FILENAME
;

escapedchar
    : AT_AT
;
%%
 /* code */
@<Function definition for int yylex(yy::parser::semantic_type* yylvalue);@>
@}

@i ast.w
